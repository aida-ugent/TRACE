import numpy as np
from numpy.random import default_rng
import scipy.spatial.distance as dist
from numba import jit, prange


# adjusted from the PaCMAP repository:
# https://github.com/YingfanWang/PaCMAP/blob/master/evaluation/evaluation.py
def random_triplet_eval(X, Y, num_triplets, hd_metric):
    """
    This is a function that is used to evaluate the lower dimension embedding.
    An triplet satisfaction score is calculated by evaluating how many randomly
    selected triplets have been violated.
    Input:
        X: A numpy array with the shape [N, p]. The higher dimension embedding
           of some dataset.
        Y: A numpy array with the shape [N, k]. The lower dimension embedding
               of some dataset.
        num_triplets (int): The number of triplets to sample per point.
        hd_metric (str): The metric to use for the higher dimension embedding.

    Output:
        acc (ndarray): The score generated by the algorithm per point.
    """
    labels, triplets = compute_hd_triplets(X, num_triplets, hd_metric)
    acc = get_triplet_accuracy(Y, labels, triplets)
    return acc


def compute_hd_triplets(X, num_triplets, hd_metric):
    """
    This is a function that is used to evaluate the lower dimension embedding.
    An triplet satisfaction score is calculated by evaluating how many randomly
    selected triplets have been violated.
    Input:
        X: A numpy array with the shape [N, p]. The higher dimension embedding
           of some dataset.
        num_triplets (int): The number of triplets to sample per point.
        hd_metric (str): The metric to use for the higher dimension embedding.

    Output:
        labels, triples (tuple(ndarray, ndarray)): The labels and triplets.
    """
    if hd_metric in dir(dist):
        hd_dist_fn = getattr(dist, hd_metric)
    else:
        raise ValueError(f"Unknown metric {hd_metric}")

    # Sampling Triplets
    anchors = np.arange(X.shape[0])
    rng = default_rng()
    triplets = rng.choice(anchors, (X.shape[0], num_triplets, 2))
    anchors = anchors.reshape((-1, 1, 1))

    # Calculate the HD distances and generate labels
    b = np.broadcast(anchors, triplets)
    distances = np.empty(b.shape)
    distances.flat = [hd_dist_fn(X[u], X[v]) for (u, v) in b]
    labels = distances[:, :, 0] < distances[:, :, 1]

    return labels, triplets


@jit(nopython=True, parallel=True, cache=True)
def get_triplet_accuracy(Y, hd_labels, triplets):
    """
    This is a function that is used to evaluate the lower dimension embedding.
    An triplet satisfaction score is calculated by evaluating how many randomly
    selected triplets have been violated.
    Input:
        Y (ndarray): A numpy array with the shape [N, 2]. The lower dimension embedding
               of some dataset.
        triplets (ndarray): The triplets to evaluate.
        hd_labels (ndarray): The labels indicating the order of the triplet in HD space.

    Output:
        acc (ndarray): The score generated by the algorithm per point.
    
    """
    n_triplets = triplets.shape[1]
    flat_triplets = triplets.flatten()
    anchors = np.repeat(np.arange(Y.shape[0]), n_triplets*triplets.shape[2])
    distances_l = np.empty((Y.shape[0], n_triplets, 2))
    for i in prange(len(flat_triplets)):
       distances_l.flat[i] = np.sqrt(np.sum((Y[flat_triplets[i]] - Y[anchors[i]]) ** 2))
    
    pred_vals = distances_l[:, :, 0] < distances_l[:, :, 1]
    correct = np.sum(pred_vals == hd_labels, axis=1)
    acc = correct / n_triplets
    return acc
